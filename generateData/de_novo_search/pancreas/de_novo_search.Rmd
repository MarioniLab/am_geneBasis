---
title: "Gene-selection-and-validation"
author: "Alsu Missarova"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Gene-selection-and-validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Load libraries

```{r setup}

library(knitr)
library(SingleCellExperiment)
library(dplyr)
library(ggplot2)
library(scran)
library(batchelor)
library(ggpubr)
library(plyr)
library(stringr)
library(BiocNeighbors)
library(irlba)
library(tibble)
library(BiocParallel)
library(BiocNeighbors)
ncores = 7
mcparam = MulticoreParam(workers = ncores)
register(mcparam)

root.dir = "/nfs/research1/marioni/alsu/geneBasis/"
#root.dir = "~/Develop/geneBasis/"
source(paste0(root.dir, "am_geneBasis/functions/de_novo_search.R"))

```

# Load data

```{r load-data}

batch = "dataset"
system = "pancreas"

# if logcounts are not saved yet - run logcounts and save
sce = readRDS( paste0( root.dir , "data/scRNA_datasets/" , system , "/" , system , ".rds") )
if (!"logcounts" %in% names(assays(sce))){
  sce = add_logcounts(sce , batch)
  saveRDS(sce , file = paste0( root.dir , "data/scRNA_datasets/" , system , "/" , system , ".rds") )
}


```

# Select HVGs and de-noise

```{r get-hvgs-and-denoise}


sce = retain_only_hvgs(sce , var.thresh = 0)

meta = as.data.frame(colData(sce))
unq.batches = unique(meta[, batch])
# if denoised logcounts are not saved yet - run denoised logcounts and save
if (!(file.exists( paste0(root.dir , "data/scRNA_datasets/" , system , "/" , system , "__denoised.Rds") ) ) ){
  logcounts_denoised = bplapply(unq.batches , function(current.batch){
    print(current.batch)
    idx = which(meta[,batch] == current.batch)
    current.sce = sce[, idx]
    current.logcounts_denoised = denoise_logcounts(current.sce, batch = NULL, n.neigh = 10, nPC = 100)
    current.sce_denoised = SingleCellExperiment(list(counts=counts(current.sce) , 
                                  logcounts = current.logcounts_denoised) , 
                             colData = colData(current.sce) )
    return(current.sce_denoised)
  }, BPPARAM = mcparam)
  sce_denoised = do.call(cbind , logcounts_denoised)
  saveRDS(sce_denoised , file = paste0(root.dir , "data/scRNA_datasets/" , system , "/" , system , "__denoised.Rds"))
} else{
  sce_denoised = readRDS( paste0(root.dir , "data/scRNA_datasets/" , system , "/" , system , "__denoised.Rds") )
}
  

```

# Get correlation-all and loadings squared

```{r get-corr-all}


corr.thresh = 0.75

meta = as.data.frame(colData(sce_denoised))
unq.batches = unique(meta[, batch])

corr_stat_all = bplapply(unq.batches , function(current.batch){
  print(current.batch)
  idx = which(meta[, batch] == current.batch)
  current.sce = sce_denoised[, idx]
  current.corr_stat_all = suppressWarnings ( get_corr_transcriptome_per_gene(current.sce , assay = "logcounts", genes = rownames(current.sce), batch = NULL, n.neigh = 5 , nPC = 100 , genes.predict = rownames(current.sce) , method = "spearman") )
  current.corr_stat_all = current.corr_stat_all[!is.na(current.corr_stat_all$corr) , ]
  colnames(current.corr_stat_all) = c("gene" , "corr.all")
  current.corr_stat_all = current.corr_stat_all[current.corr_stat_all$corr.all > corr.thresh , ]
  
  current.corr_stat_all$batch = current.batch
  return(current.corr_stat_all)
} , BPPARAM = mcparam)
corr_stat_all = do.call(rbind , corr_stat_all)
saveRDS( corr_stat_all , file = paste0(root.dir , "data/scRNA_datasets/" , system , "/" , system , "corr_stat_all.Rds"))


```

# Get genes basis

## Using minimum correlation

```{r get-genes-basis-min-corr}


meta = as.data.frame(colData(sce_denoised))
unq.batches = unique(meta[, batch])
eps = 0.00001


min.corr.thresh.grid = c( 0.9 , 0.95 )


genes_stat = lapply(min.corr.thresh.grid , function(min.corr.thresh){
  current.genes_stat = list()
  for (idx.batch in c(1:length(unq.batches))){
    print(unq.batches[idx.batch])
    print(idx.batch)
    idx = which(meta[, batch] %in% unq.batches[idx.batch])
    current.sce = sce_denoised[, idx]
    current.corr_stat_all = corr_stat_all[corr_stat_all$batch == unq.batches[idx.batch] , ]
    current.corr_stat_all = current.corr_stat_all[order(current.corr_stat_all$corr.all , decreasing = T) , ]
    current.genes_keep = as.character( current.corr_stat_all$gene )
    if (idx.batch == 1){
      genes_all = as.character( current.corr_stat_all$gene[1:3] )
    }
    min.corr = 0
    while(min.corr < min.corr.thresh ){
      corr_stat_genes = suppressWarnings( get_corr_transcriptome_per_gene(current.sce , assay = "logcounts" , genes = genes_all , batch = NULL, n.neigh = 5 , nPC = length(genes_all) - 1 , genes.predict = current.genes_keep , method = "spearman"))
      corr_stat_genes = corr_stat_genes[!corr_stat_genes$gene %in% genes_all , ]
    
      corr_stat_genes$corr[is.na(corr_stat_genes$corr)] = eps
      corr_stat_genes$corr[corr_stat_genes$corr <= 0] = eps
    
      corr_stat_genes = merge(corr_stat_genes , current.corr_stat_all , all.x = T , all.y = F)
      corr_stat_genes$corr.ratio = corr_stat_genes$corr/corr_stat_genes$corr.all
    
      min.corr = min(corr_stat_genes$corr.ratio)
      if (min.corr >= min.corr.thresh){
        break
        print("sample done")
      } else {
        idx = which(corr_stat_genes$corr.ratio == min.corr)
        gene = corr_stat_genes$gene[idx[1]]
        genes_all = c(genes_all , gene)
        print(min.corr)
        print(gene)
        n = length(current.genes_stat)
        current.genes_stat[[n+1]] = data.frame(gene = gene , corr.all = corr_stat_genes$corr.all[corr_stat_genes$gene == gene] , 
                                       corr.ratio = corr_stat_genes$corr.ratio[corr_stat_genes$gene == gene] , batch = unq.batches[idx.batch])
      }
    }
  }
  current.genes_stat = do.call(rbind , current.genes_stat)
  return(current.genes_stat)
})
names(genes_stat) = paste0("corr_thresh" , min.corr.thresh.grid)
saveRDS(genes_stat , file = paste0(root.dir , "data/gene_basis/" , system  , "/" , system , "__minCorr_selection.Rds"))



```



